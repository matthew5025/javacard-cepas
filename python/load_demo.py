#!/usr/bin/env python3
"""
Load a fixed CEPAS demo snapshot into purse index 3 using the applet's
customization commands (INS=0xF0). Intended to reproduce the output seen
from python/card_probe.py against the captured physical card.

Usage:
  python3 python/load_demo.py [--reader "substring"]

After running, re-run python/card_probe.py to confirm the purse info and
30 transaction logs match the reference dump.
"""

import argparse
import sys
from dataclasses import dataclass
from typing import Iterable, List, Tuple

try:
    from smartcard.System import readers
    from smartcard.CardConnection import CardConnection
    from smartcard.Exceptions import NoReadersException, NoCardException
except ImportError:
    sys.exit("pyscard is required. Install with: pip install pyscard")

CLA = 0x90
INS_CUSTOM = 0xF0
P1_DEMO = 0x03  # purse index to populate
APP_AID = [0xA0, 0x00, 0x00, 0x03, 0x41, 0x00, 0x01, 0x01]

@dataclass
class TransactionLog:
    type: int
    amount: List[int]
    datetime: List[int]
    user_data: List[int]

    def to_bytes(self) -> List[int]:
        return [self.type] + self.amount + self.datetime + self.user_data


@dataclass
class PurseSnapshot:
    version: int
    status: int
    purse_balance: List[int]
    autoload_amount: List[int]
    can: List[int]
    csn: List[int]
    expiry: List[int]
    creation: List[int]
    last_credit_trp: List[int]
    last_credit_hdr: List[int]
    last_trn_trp: List[int]
    last_trn_rec: List[int]
    issuer_data: List[int]
    logs: List[TransactionLog]
    tail_byte: int = 0x03  # trailing byte captured from the card dump

    def issuer_len(self) -> int:
        return len(self.issuer_data)

    def num_logs(self) -> int:
        return len(self.logs)

    def to_full_image(self) -> List[int]:
        """Return 95-byte purse image matching captured layout (no logs included)."""
        out: List[int] = []
        out.append(self.version)
        out.append(self.status)
        out += self.purse_balance
        out += self.autoload_amount
        out += self.can
        out += self.csn
        out += self.expiry
        out += self.creation
        out += self.last_credit_trp
        out += self.last_credit_hdr
        out.append(self.num_logs())
        out.append(self.issuer_len())
        out += self.last_trn_trp
        out += self.last_trn_rec
        out += self.issuer_data
        out.append(self.tail_byte)
        return out

    def field_payloads(self) -> List[Tuple[int, List[int]]]:
        """Field-by-field writes matching INS 0xF0 P2 tags."""
        return [
            (0x00, [self.version]),
            (0x01, [self.status]),
            (0x02, self.purse_balance),
            (0x03, self.autoload_amount),
            (0x04, self.can),
            (0x05, self.csn),
            (0x06, self.expiry),
            (0x07, self.creation),
            (0x08, self.last_credit_trp),
            (0x09, self.last_credit_hdr),
            (0x0B, self.last_trn_trp),
            (0x0C, self.last_trn_rec),
            (0x0D, self.issuer_data),
        ]


def default_snapshot() -> PurseSnapshot:
    issuer_data = list(bytes.fromhex(
        "020080302A000001010000000000000000000000000000000000000000FFFFFF"
    ))

    logs = [
        TransactionLog(0x11, [0x00, 0x00, 0x00], [0x26, 0x31, 0xD4, 0x7C], [0x4D, 0x52, 0x4D, 0x20, 0x47, 0x54, 0x4D, 0x20]),
        TransactionLog(0xA0, [0xFF, 0xFF, 0xFC], [0x25, 0xD7, 0xCD, 0x28], [0x55, 0x53, 0x50, 0x50, 0x20, 0x20, 0x20, 0x00]),
        TransactionLog(0xA0, [0xFF, 0xFF, 0xF9], [0x25, 0xCA, 0xE7, 0x6D], [0x55, 0x53, 0x50, 0x50, 0x20, 0x20, 0x20, 0x00]),
        TransactionLog(0xA0, [0xFF, 0xFF, 0xCE], [0x24, 0xBA, 0x21, 0x7C], [0x4E, 0x4C, 0x42, 0x44, 0x20, 0x20, 0x20, 0x00]),
        TransactionLog(0xA0, [0xFF, 0xFF, 0xF1], [0x24, 0xA2, 0x7A, 0xAA], [0x4E, 0x4C, 0x42, 0x44, 0x20, 0x20, 0x20, 0x00]),
        TransactionLog(0xA0, [0xFF, 0xFF, 0xF1], [0x24, 0x55, 0xF3, 0x44], [0x4E, 0x4C, 0x42, 0x44, 0x20, 0x20, 0x20, 0x00]),
        TransactionLog(0xA0, [0xFF, 0xFF, 0x65], [0x24, 0x54, 0x72, 0xAD], [0x4E, 0x4C, 0x42, 0x44, 0x20, 0x20, 0x20, 0x00]),
        TransactionLog(0xF0, [0x00, 0x04, 0x02], [0x24, 0x54, 0x46, 0xC8], [0x1E, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
        TransactionLog(0x76, [0x00, 0x00, 0x27], [0x24, 0x49, 0xE9, 0xB8], [0x53, 0x56, 0x43, 0x20, 0x35, 0x30, 0x36, 0x00]),
        TransactionLog(0x31, [0xFF, 0xFF, 0x00], [0x24, 0x49, 0xDF, 0xF8], [0x53, 0x56, 0x43, 0x20, 0x35, 0x30, 0x36, 0x00]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x96], [0x24, 0x49, 0xA3, 0x8B], [0x54, 0x41, 0x4D, 0x2D, 0x43, 0x4E, 0x54, 0x20]),
        TransactionLog(0x31, [0xFF, 0xFF, 0xB3], [0x24, 0x49, 0x97, 0x7E], [0x53, 0x56, 0x43, 0x20, 0x20, 0x32, 0x39, 0x00]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x9E], [0x24, 0x48, 0x85, 0xA9], [0x44, 0x56, 0x52, 0x2D, 0x52, 0x44, 0x48, 0x20]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x44], [0x24, 0x48, 0x50, 0xBD], [0x54, 0x41, 0x4D, 0x2D, 0x44, 0x56, 0x52, 0x20]),
        TransactionLog(0x76, [0x00, 0x00, 0x08], [0x24, 0x47, 0x43, 0x7E], [0x53, 0x56, 0x43, 0x20, 0x35, 0x31, 0x38, 0x00]),
        TransactionLog(0x31, [0xFF, 0xFF, 0x87], [0x24, 0x47, 0x3B, 0x41], [0x53, 0x56, 0x43, 0x20, 0x35, 0x31, 0x38, 0x00]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x6E], [0x24, 0x47, 0x33, 0xB9], [0x44, 0x56, 0x52, 0x2D, 0x42, 0x46, 0x44, 0x20]),
        TransactionLog(0x75, [0x00, 0x03, 0xE8], [0x24, 0x47, 0x2A, 0x39], [0x44, 0x56, 0x52, 0x20, 0x47, 0x54, 0x4D, 0x20]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x44], [0x24, 0x46, 0xF6, 0x73], [0x54, 0x41, 0x4D, 0x2D, 0x44, 0x56, 0x52, 0x20]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x85], [0x24, 0x46, 0x2A, 0x96], [0x44, 0x56, 0x52, 0x2D, 0x50, 0x50, 0x4A, 0x20]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x44], [0x24, 0x45, 0xEA, 0x6D], [0x54, 0x41, 0x4D, 0x2D, 0x44, 0x56, 0x52, 0x20]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x49], [0x24, 0x43, 0xC9, 0x8E], [0x42, 0x53, 0x48, 0x2D, 0x54, 0x41, 0x4D, 0x20]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x7D], [0x24, 0x42, 0x68, 0x38], [0x44, 0x42, 0x4E, 0x2D, 0x53, 0x45, 0x52, 0x20]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x94], [0x24, 0x42, 0x61, 0xC7], [0x54, 0x41, 0x50, 0x2D, 0x44, 0x42, 0x4E, 0x20]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x6F], [0x24, 0x42, 0x37, 0x9A], [0x50, 0x4C, 0x43, 0x2D, 0x54, 0x41, 0x50, 0x20]),
        TransactionLog(0x75, [0x00, 0x03, 0xE8], [0x24, 0x42, 0x32, 0xA8], [0x50, 0x4C, 0x43, 0x20, 0x47, 0x54, 0x4D, 0x20]),
        TransactionLog(0xA0, [0xFF, 0xFF, 0xE2], [0x24, 0x3F, 0x88, 0x42], [0x4E, 0x4C, 0x42, 0x44, 0x20, 0x20, 0x20, 0x00]),
        TransactionLog(0x30, [0xFF, 0xFF, 0x77], [0x24, 0x3E, 0x64, 0x6E], [0x43, 0x47, 0x41, 0x2D, 0x54, 0x41, 0x4D, 0x20]),
        TransactionLog(0x76, [0x00, 0x00, 0x04], [0x24, 0x3D, 0x0A, 0x16], [0x53, 0x56, 0x43, 0x20, 0x35, 0x30, 0x36, 0x00]),
        TransactionLog(0x31, [0xFF, 0xFF, 0x02], [0x24, 0x3C, 0xFA, 0x8B], [0x53, 0x56, 0x43, 0x20, 0x35, 0x30, 0x36, 0x00]),
    ]

    return PurseSnapshot(
        version=0x02,
        status=0x00,
        purse_balance=[0x00, 0x00, 0x06],
        autoload_amount=[0x00, 0x07, 0xD0],
        can=[0x80, 0x09, 0x13, 0x00, 0x00, 0x82, 0x95, 0x70],
        csn=[0x04, 0x3A, 0x38, 0x00, 0x0D, 0x00, 0x12, 0xE0],
        expiry=[0x1E, 0xD9],
        creation=[0x1A, 0x14],
        last_credit_trp=[0x00, 0x01, 0x21, 0xFF],
        last_credit_hdr=[0x75, 0x00, 0x03, 0xE8, 0x24, 0x47, 0x2A, 0x39],
        last_trn_trp=[0x00, 0x17, 0xF1, 0x03],
        last_trn_rec=[0x11, 0x00, 0x00, 0x00, 0x26, 0x31, 0xD4, 0x7C, 0x4D, 0x52, 0x4D, 0x20, 0x47, 0x54, 0x4D, 0x20],
        issuer_data=issuer_data,
        logs=logs,
        tail_byte=0x03,
    )


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Load CEPAS demo data into purse 3")
    p.add_argument("--reader", help="substring to choose a specific reader (defaults to first available)")
    return p.parse_args()


def pick_reader_with_card(preferred: str):
    try:
        available = readers()
    except NoReadersException:
        sys.exit("No PC/SC readers found. Is pcscd/pcsclite running and a reader connected?")

    if not available:
        sys.exit("No PC/SC readers found.")

    candidates = [r for r in available if preferred.lower() in r.name.lower()] if preferred else list(available)
    if not candidates:
        sys.exit(f"No reader name contains '{preferred}'. Available: {[r.name for r in available]}")

    last_error = None
    for r in candidates:
        conn = r.createConnection()
        for proto in (CardConnection.T1_protocol, CardConnection.T0_protocol):
            try:
                conn.connect(proto)
                return r, conn
            except NoCardException as e:
                last_error = e
            except Exception as e:
                last_error = e
    if preferred:
        sys.exit(f"Reader '{preferred}' found but no card present/usable: {last_error}")
    sys.exit(f"No readers had a present/usable card. Last error: {last_error}")


def to_hex(data: Iterable[int]) -> str:
    return "".join(f"{b:02X}" for b in data)


def send(conn: CardConnection, apdu: Iterable[int], label: str) -> Tuple[int, List[int]]:
    apdu_list = list(apdu)
    data, sw1, sw2 = conn.transmit(apdu_list)
    sw = (sw1 << 8) | sw2
    print(f"{label:<24} -> SW={sw:04X} len={len(data)} data={to_hex(data)}")
    return sw, data


def require_9000(sw: int, op: str):
    if sw != 0x9000:
        sys.exit(f"{op} failed with SW={sw:04X}")


def main() -> None:
    args = parse_args()
    reader, conn = pick_reader_with_card(args.reader)
    print(f"Using reader: {reader.name}")

    snapshot = default_snapshot()

    # Create purse slot
    sw, _ = send(conn, [CLA, INS_CUSTOM, P1_DEMO, 0xFF], "Create purse")
    require_9000(sw, "Create purse")

    # Try loading the full 95-byte purse image (p2=0xFE). If it fails, fall back to field-by-field.
    full_image = snapshot.to_full_image()
    sw_full, _ = send(conn, [CLA, INS_CUSTOM, P1_DEMO, 0xFE, len(full_image)] + full_image, "Load full image")

    def set_field(tag: int, payload: List[int], label: str):
        apdu = [CLA, INS_CUSTOM, P1_DEMO, tag, len(payload)] + payload
        sw_local, _ = send(conn, apdu, label)
        require_9000(sw_local, label)

    if sw_full != 0x9000:
        for tag, payload in snapshot.field_payloads():
            set_field(tag, payload, f"Set field 0x{tag:02X}")

    # Transaction logs
    for idx, log in enumerate(snapshot.logs):
        set_field(0x0E, log.to_bytes(), f"Add log #{idx:02d}")

    # Optionally lock the purse to prevent further customization edits
    sw, _ = send(conn, [CLA, INS_CUSTOM, P1_DEMO, 0xFD], "Lock purse")
    require_9000(sw, "Lock purse")

    print("\nDemo data loaded. Re-run python/card_probe.py to verify output.")

    try:
        conn.disconnect()
    except Exception:
        pass


if __name__ == "__main__":
    main()
